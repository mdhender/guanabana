# Lesson 15: Code Generation

**Goal**: Generate a working Go parser from the parse tables. The generated
parser follows Lemon's architecture: the lexer drives the parser by calling
a `Parse(tokenType, tokenValue)` function for each token.

## What you will build in this lesson

- A code generator that emits a standalone `.go` file containing a working
  shift/reduce parser
- The generated parser API: `NewParser()`, `Parse(tokenType int, value interface{})`,
  `ParseComplete() (interface{}, error)`
- A parser runtime that implements the shift/reduce loop
- Token type constants in the generated file
- An option to generate a Go package instead of a standalone file
- Tests that generate a parser and compile it

## Key concepts

**Lexer-driven parsing (Lemon style)**: In Lemon, the lexer calls the parser
for each token:
```go
parser := NewParser()
for token := lexer.Next(); token.Type != EOF; token = lexer.Next() {
    parser.Parse(token.Type, token.Value)
}
parser.Parse(0, nil) // signal EOF
result := parser.ParseComplete()
```

**Generated parser structure**: The generated file contains:
1. Token type constants (matching the grammar's terminals)
2. A `Parser` struct with a state stack and value stack
3. The ACTION and GOTO tables as Go data (slices)
4. The `Parse` method implementing the shift/reduce loop
5. Reduce action handlers (calling user-provided action code)

**Shift/reduce engine**:
```
Parse(tokenType, value):
    loop:
        state = top of state stack
        action = ACTION[state][tokenType]
        switch action.Kind:
            Shift:
                push (state=action.State, value) onto stacks
                return  // wait for next token
            Reduce:
                rule = rules[action.RuleIndex]
                pop len(rule.RHS) entries from stacks
                execute rule's action code → result value
                gotoState = GOTO[top of stack][rule.LHS]
                push (state=gotoState, value=result) onto stacks
                continue loop  // don't consume token yet
            Accept:
                set result, return
            Error:
                handle syntax error
```

**Code generation via `text/template`**: We use Go's `text/template` package
to generate the parser source code. The template is parameterized by the
parse tables, token constants, and action code.

## Inputs / Outputs

### Files to create

| File | Purpose |
|------|---------|
| `internal/codegen/generate.go` | Code generator main logic |
| `internal/codegen/template.go` | Go template for the generated parser |
| `internal/codegen/generate_test.go` | Code generation tests |
| `internal/runtime/parser.go` | Shared runtime types (optional, for package mode) |

### Functions

```go
package codegen

import "github.com/mdhender/guanabana/internal/lalr"

type Config struct {
    PackageName   string // Go package name for the generated file
    ParserName    string // Name of the parser struct (e.g., "Parser")
    OutputFile    string // Path to write the generated file
    Standalone    bool   // true = single file, false = package
    Grammar       *grammar.Grammar
    Table         *lalr.ParseTable
}

// Generate writes a Go parser file based on the parse tables.
func Generate(cfg *Config) ([]byte, error)
```

### Generated parser API

```go
// In the generated file:

type Parser struct {
    stateStack []int
    valueStack []interface{}
    result     interface{}
    err        error
}

func NewParser() *Parser
func (p *Parser) Parse(tokenType int, value interface{})
func (p *Parser) ParseComplete() (interface{}, error)
```

## Algorithm sketch

### Code generation

```
function Generate(config):
    data = {
        PackageName: config.PackageName,
        ParserName: config.ParserName,
        Tokens: list of (name, ID) for each terminal,
        NumStates: table.NumStates,
        ActionTable: serialize table.Action as Go literal,
        GotoTable: serialize table.Goto as Go literal,
        Rules: for each rule: {LHS nonterminal index, RHS length, action code},
        NumRules: len(rules),
    }

    tmpl = parse Go template
    output = execute template with data
    formatted = gofmt(output)  // use go/format package
    return formatted
```

### Template structure (simplified)

```go
// Generated by guanabana. DO NOT EDIT.
package {{.PackageName}}

// Token types
const (
    {{range .Tokens}}{{.Name}} = {{.ID}}
    {{end}}
)

// Action kinds
const (
    _actError  = 0
    _actShift  = 1
    _actReduce = 2
    _actAccept = 3
)

type {{.ParserName}} struct {
    stateStack []int
    valueStack []interface{}
    result     interface{}
    err        error
}

func New{{.ParserName}}() *{{.ParserName}} {
    return &{{.ParserName}}{
        stateStack: []int{0},
    }
}

// Parse feeds one token to the parser. Call with tokenType=0 for EOF.
func (p *{{.ParserName}}) Parse(tokenType int, value interface{}) {
    for {
        state := p.stateStack[len(p.stateStack)-1]
        act := _actionTable[state][tokenType]
        switch act & 0x3 { // low 2 bits = kind
        case _actShift:
            target := act >> 2
            p.stateStack = append(p.stateStack, target)
            p.valueStack = append(p.valueStack, value)
            return // consume token
        case _actReduce:
            ruleIdx := act >> 2
            p.reduce(ruleIdx)
            continue // don't consume token
        case _actAccept:
            p.result = p.valueStack[len(p.valueStack)-1]
            return
        default: // error
            p.err = fmt.Errorf("syntax error in state %d on token %d", state, tokenType)
            return
        }
    }
}

// reduce applies a grammar rule.
func (p *{{.ParserName}}) reduce(ruleIdx int) {
    rule := _ruleTable[ruleIdx]
    n := rule.rhsLen
    // Pop n entries
    values := make([]interface{}, n)
    copy(values, p.valueStack[len(p.valueStack)-n:])
    p.stateStack = p.stateStack[:len(p.stateStack)-n]
    p.valueStack = p.valueStack[:len(p.valueStack)-n]

    // Execute action
    var result interface{}
    switch ruleIdx {
    {{range .Rules}}{{if .Action}}
    case {{.Index}}:
        {{.Action}}
    {{end}}{{end}}
    }

    // GOTO
    topState := p.stateStack[len(p.stateStack)-1]
    gotoState := _gotoTable[topState][rule.lhsIdx]
    p.stateStack = append(p.stateStack, gotoState)
    p.valueStack = append(p.valueStack, result)
}
```

## Repository changes

| Action | File |
|--------|------|
| Create | `internal/codegen/generate.go` |
| Create | `internal/codegen/template.go` |
| Create | `internal/codegen/generate_test.go` |
| Create | `internal/runtime/parser.go` (optional shared types) |

## Unit tests (pass/fail gate)

### Test 1: Generated code compiles

```go
func TestGeneratedCodeCompiles(t *testing.T) {
    g := buildCalcGrammar() // simple expr → expr PLUS term | term; term → NUM
    table := buildFullTable(g)

    cfg := &Config{
        PackageName: "testparser",
        ParserName:  "Parser",
        Standalone:  true,
        Grammar:     g,
        Table:       table,
    }

    code, err := Generate(cfg)
    if err != nil {
        t.Fatalf("Generate error: %v", err)
    }

    // Verify it's valid Go by formatting it
    _, err = format.Source(code)
    if err != nil {
        t.Errorf("generated code doesn't compile: %v", err)
        t.Log(string(code))
    }
}
```

### Test 2: Generated code contains token constants

```go
func TestGeneratedTokenConstants(t *testing.T) {
    g := buildCalcGrammar()
    table := buildFullTable(g)
    cfg := &Config{PackageName: "p", ParserName: "Parser", Grammar: g, Table: table}
    code, _ := Generate(cfg)

    src := string(code)
    if !strings.Contains(src, "PLUS") {
        t.Error("generated code should contain PLUS constant")
    }
    if !strings.Contains(src, "NUM") {
        t.Error("generated code should contain NUM constant")
    }
}
```

### Test 3: Generated code contains tables

```go
func TestGeneratedContainsTables(t *testing.T) {
    g := buildCalcGrammar()
    table := buildFullTable(g)
    cfg := &Config{PackageName: "p", ParserName: "Parser", Grammar: g, Table: table}
    code, _ := Generate(cfg)

    src := string(code)
    if !strings.Contains(src, "_actionTable") {
        t.Error("generated code should contain _actionTable")
    }
    if !strings.Contains(src, "_gotoTable") {
        t.Error("generated code should contain _gotoTable")
    }
}
```

### Test 4: Action table has correct dimensions

```go
func TestActionTableDimensions(t *testing.T) {
    g := buildCalcGrammar()
    table := buildFullTable(g)
    cfg := &Config{PackageName: "p", ParserName: "Parser", Grammar: g, Table: table}
    code, _ := Generate(cfg)

    // The generated action table should reference the right number of states
    src := string(code)
    stateCount := fmt.Sprintf("[%d]", table.NumStates)
    if !strings.Contains(src, stateCount) {
        t.Errorf("expected %s in generated tables", stateCount)
    }
}
```

### Test 5: Package name in output

```go
func TestPackageName(t *testing.T) {
    g := buildCalcGrammar()
    table := buildFullTable(g)
    cfg := &Config{PackageName: "mycalc", ParserName: "Parser", Grammar: g, Table: table}
    code, _ := Generate(cfg)

    if !strings.HasPrefix(string(code), "// Generated") {
        t.Error("generated code should start with generated comment")
    }
    if !strings.Contains(string(code), "package mycalc") {
        t.Error("generated code should contain package declaration")
    }
}
```

## Common mistakes

1. **Not formatting with `go/format`**: Generated code must be valid Go.
   Use `format.Source()` to both validate and format the output.

2. **Hardcoding table values**: The template must be parameterized. Don't
   embed literal table values in the template.

3. **Wrong encoding of actions**: If you pack action kind and value into a
   single int, be careful with the encoding/decoding. Test edge cases.

4. **Forgetting the reduce action handlers**: Each rule with action code
   needs its own case in the reduce switch. Missing one means the action
   code is silently lost.

5. **Not handling empty action code**: Rules without action code should
   still work (result is nil or zero value).

## Codex prompt for this lesson

```
Read the lesson specification in docs/lesson-15-codegen.md and implement
exactly what it describes.

Scope:
- Create internal/codegen/generate.go with the Generate function and Config
  struct.
- Create internal/codegen/template.go with the Go text/template for the
  generated parser. The template should produce a valid, self-contained Go
  file with: package declaration, token constants, parser struct, NewParser,
  Parse, and reduce methods, ACTION and GOTO tables as Go slice literals.
- Create internal/codegen/generate_test.go with all five tests.
- Use go/format to validate and format the generated code.
- The generated parser must follow Lemon's lexer-driven architecture:
  the lexer calls Parse(tokenType, value) for each token.
- Use only the Go standard library.
- Keep the generated code readable and commented.
- Leave TODO: "// TODO(lesson-16): end-to-end examples"

Run `go test ./internal/codegen/...` and ensure all tests pass.
```

## Checkpoint questions

1. Why does the generated parser use a loop inside `Parse()` instead of
   just executing one action per call?
2. What does `go/format.Source()` do and why is it important for code
   generation?
3. In the shift/reduce engine, when does the parser consume the input token
   and when does it not?
4. Why are the ACTION and GOTO tables embedded in the generated file rather
   than loaded at runtime?
5. How would you add support for the `%extra_argument` directive in the
   generated parser?
